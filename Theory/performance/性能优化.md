# 性能优化

大家好， 我是冯申翔，今天做一个关于性能优化的分享。

性能优化是关于节约和协调的学问。

如何花最少成本完成最多的任务和如何在同时执行多个任务的时候合理分配资源。

我们最近做的是首屏渲染的优化， 标准是要用户可以快速进入一个稳定的页面。

快速大家都知道， 稳定的意思是页面上元素数量和位置变动幅度。

FMP是一个描述快速稳定页面的时间点，所以我们上周聚焦于怎么加快用户进入页面FMP的时间，发现了几个问题和对应的解决方案。

我们使用的工具是react profiler, 运行后可以发现每个元素的执行花费时间和执行的时间点

我们发现：

   1. 不必要渲染： headerWidget过多占用渲染资源，**MobileMenu** 根本没有渲染到页面上

   2. 页面io事件没有统一控制

         1. 比如数据没有统一取，会导致多次渲染

         2. 数据多次获取，导致页面上其他部分还没有渲染完毕就再次更新，占用了渲染资源

            尽可能将io提取出来， 统一管理，统一 取数据，然后setState,在页面没有稳定前不允许再次更新数据，触发更新

            

      mainPage中的componentDidMount中会执行取数据操作，在取数据之前会有初次渲染， 取到数据后setState会触发重新渲染，引起渲染性能的浪费。

      方案：我们要在取数据之前放一个占位图（或者loading）。取完数据之后再执行渲染任务

​				tradePage中由于有多个异步任务将setState了多次，由于使用custom hooks进行包装， 比较隐匿。

​				由于异步任务多次setState肯定会造成多次渲染，这个是react中batchUpate的遗留问题，react给了一个方案使用	react-dom中的unstable_batchedupdates方法批量将异步操作后的几次setState方法集中更新。

​				所以我们的解决方案是：

- 对于io事件， 设计了一个方法,	包含所有的io处理后的数据和set方法，将所有的io事件也就是promise放入promise.all中集中等待结果，随后用unstable_batchedupdates包裹不同执行的set方法

- 对于其他情况，比如说要使用setTimeout中来执行任务了， 建议自行使用unstable_batchedupdates来进行更新

3. context会占用过多资源，每次context更新一部分内容，相关联的context.consumer就会同时更新









